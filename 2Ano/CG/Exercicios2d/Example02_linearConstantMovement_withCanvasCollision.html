<!DOCTYPE html>
<html lang="pt-PT">

<head>
  <meta charset="utf-8" />
  <title>Movimento retilíneo com ressalto</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      padding: 20px;
      background: #f8fafc;
    }

    canvas {
      border: 1px solid #1e3a8a;
      background: white;
    }

    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    button {
      padding: 6px 10px;
      font-size: 14px;
    }

    label {
      font-size: 14px;
    }

    input[type="range"] {
      width: 120px;
    }
  </style>
</head>

<body>
  <h2>Movimento retilíneo com ressalto nas bordas</h2>
  <canvas id="myCanvas" width="600" height="400"></canvas>

  <div class="controls">
    <button id="leftBtn">⬅️ Girar Esquerda</button>
    <button id="rightBtn">Girar Direita ➡️</button>
    <label>Velocidade: <span id="speedValue">1</span></label>
    <input type="range" id="speedSlider" min="0" max="5" step="0.1" value="1">
    <button id="resetBtn">Reiniciar</button>
  </div>

  <div style="font-size:10px;">
    <strong>Nota:</strong> Ao colisar com as bordas o círculo reflete (componente invertida) e o ângulo é actualizado
    automaticamente.
  </div>

  <script>
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    const circle = {
      R: 20,
      COLOR: "orange",
      x: W / 2,
      y: H / 2,
      speed: 1,               // pixels per frame
      angle: Math.PI / 4,     // initial angle (45 degrees)

      draw() {
        ctx.fillStyle = this.COLOR;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.R, 0, Math.PI * 2);
        ctx.fill();
      },

      update() {
        // displacement in X and Y based on angle and speed
        this.dX = this.speed * Math.cos(this.angle);
        this.dY = this.speed * Math.sin(this.angle);
        this.x += this.dX;  // update horizontal position
        this.y += this.dY;  // update vertical position

        // check Canvas vertical collisions
        if (this.x < this.R || this.x > W - this.R) {
          this.dX = -this.dX;
          this.angle = Math.atan2(this.dY, this.dX);
        }
        // check Canvas horizontal collisions
        if (this.y < this.R || this.y > H - this.R) {
          this.dY = -this.dY;
          this.angle = Math.atan2(this.dY, this.dX);
        }

      },

      drawVector() {
        // draw direction vector (arrow)
        const arrowLen = Math.min(80, this.speed * 12 + 20); // arrow length scales with speed
        const x2 = this.x + arrowLen * Math.cos(this.angle);
        const y2 = this.y + arrowLen * Math.sin(this.angle);
        ctx.strokeStyle = "#0ea5e9"; // light blue
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        // arrowhead
        const head = 10;
        const leftX = x2 - head * Math.cos(this.angle - Math.PI / 6);
        const leftY = y2 - head * Math.sin(this.angle - Math.PI / 6);
        const rightX = x2 - head * Math.cos(this.angle + Math.PI / 6);
        const rightY = y2 - head * Math.sin(this.angle + Math.PI / 6);
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(leftX, leftY);
        ctx.lineTo(rightX, rightY);
        ctx.closePath();
        ctx.fillStyle = "#0ea5e9";
        ctx.fill();
      },
    };

    onload = () => {
      render();
    };

    function render() {
      ctx.clearRect(0, 0, W, H);
      circle.draw();
      circle.drawVector();
      circle.update();

      // handle rotation from UI buttons
      if (rotate === "left") circle.angle -= 0.03;
      else if (rotate === "right") circle.angle += 0.03;


      // info text
      ctx.fillStyle = "black";
      ctx.font = "14px Arial";
      ctx.fillText(`Ângulo: ${(circle.angle * 180 / Math.PI).toFixed(1)}°`, 10, 20);
      ctx.fillText(`Velocidade: ${circle.speed} px/frame`, 10, 40);

      requestAnimationFrame(render);
    }

    // UI CONTROLS
    // Direction control buttons
    let rotate = null;
    document.getElementById("leftBtn").onmousedown = () => rotate = "left";
    document.getElementById("rightBtn").onmousedown = () => rotate = "right";
    document.getElementById("leftBtn").onmouseup = () => rotate = null;
    document.getElementById("rightBtn").onmouseup = () => rotate = null;
    // Speed control slider
    document.getElementById("speedSlider").addEventListener("input", () => {
      circle.speed = parseFloat(speedSlider.value);
      speedValue.textContent = circle.speed.toFixed(1);
    });
    // Reset button
    document.getElementById("resetBtn").onclick = () => {
      circle.x = W / 2;
      circle.y = H / 2;
      circle.angle = Math.random() * 2 * Math.PI;
    };

  </script>
</body>

</html>